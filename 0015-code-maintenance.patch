From f02050a7513dfb8a91001b2e5d09fac8d072e4dc Mon Sep 17 00:00:00 2001
From: Kai Nagel <2008@kainagel.org>
Date: Sat, 25 Jul 2015 11:43:15 +0200
Subject: [PATCH 15/16] code maintenance

---
 .../carsharing/qsim/CarsharingAgentFactory.java    |  5 +-
 .../qsim/CarsharingPersonDriverAgentImpl.java      | 38 +++++++--------
 .../carsharing/qsim/CarsharingQsimFactory.java     | 54 +++++++++++-----------
 .../simulation/ParkingInfrastructureManager.java   |  2 +
 4 files changed, 46 insertions(+), 53 deletions(-)

diff --git a/contribs/carsharing/src/main/java/org/matsim/contrib/carsharing/qsim/CarsharingAgentFactory.java b/contribs/carsharing/src/main/java/org/matsim/contrib/carsharing/qsim/CarsharingAgentFactory.java
index 5179e01..2ca133c 100644
--- a/contribs/carsharing/src/main/java/org/matsim/contrib/carsharing/qsim/CarsharingAgentFactory.java
+++ b/contribs/carsharing/src/main/java/org/matsim/contrib/carsharing/qsim/CarsharingAgentFactory.java
@@ -2,7 +2,6 @@ package org.matsim.contrib.carsharing.qsim;
 
 import javax.inject.Provider;
 
-import org.matsim.api.core.v01.Scenario;
 import org.matsim.api.core.v01.population.Person;
 import org.matsim.core.mobsim.framework.MobsimDriverAgent;
 import org.matsim.core.mobsim.qsim.agents.AgentFactory;
@@ -12,15 +11,13 @@ import org.matsim.core.router.TripRouter;
 
 public class CarsharingAgentFactory implements AgentFactory{
 	private final Netsim simulation;
-	private final Scenario scenario;
 	private CarSharingVehicles carSharingVehicles;
 
 	private TripRouter tripRouter;
 	
 	
-	public CarsharingAgentFactory(final Netsim simulation, final Scenario scenario, final Provider<TripRouter> tripRouterProvider, CarSharingVehicles carSharingVehicles) {
+	public CarsharingAgentFactory(final Netsim simulation, final Provider<TripRouter> tripRouterProvider, CarSharingVehicles carSharingVehicles) {
 		this.simulation = simulation;
-		this.scenario = scenario;
 		this.carSharingVehicles = carSharingVehicles;
 				
 		Provider<TripRouter> tripRouterFactory = tripRouterProvider;
diff --git a/contribs/carsharing/src/main/java/org/matsim/contrib/carsharing/qsim/CarsharingPersonDriverAgentImpl.java b/contribs/carsharing/src/main/java/org/matsim/contrib/carsharing/qsim/CarsharingPersonDriverAgentImpl.java
index 0550fb5..38f5ed3 100644
--- a/contribs/carsharing/src/main/java/org/matsim/contrib/carsharing/qsim/CarsharingPersonDriverAgentImpl.java
+++ b/contribs/carsharing/src/main/java/org/matsim/contrib/carsharing/qsim/CarsharingPersonDriverAgentImpl.java
@@ -127,10 +127,10 @@ public class CarsharingPersonDriverAgentImpl implements MobsimDriverAgent, Mobsi
 	public final void endLegAndComputeNextState(final double now) {
 		if (this.getVehicle()!=null && (this.getVehicle().getId().toString().startsWith("TW") ||
 				this.getVehicle().getId().toString().startsWith("OW") || 
-				this.getVehicle().getId().toString().startsWith("FF")))
-
-			parkCSVehicle( );			
-
+				this.getVehicle().getId().toString().startsWith("FF"))) 
+		{
+			parkCSVehicle( this.getCurrentLinkId() );			
+		}
 		this.basicAgentDelegate.endLegAndComputeNextState(now);
 		if ( this.getState()!=State.ABORT ) {
 
@@ -138,26 +138,21 @@ public class CarsharingPersonDriverAgentImpl implements MobsimDriverAgent, Mobsi
 		}
 	}	
 
-	private void parkCSVehicle() {
-		Leg currentLeg = (Leg) this.basicAgentDelegate.getCurrentPlanElement() ;
-		Scenario scenario = this.basicAgentDelegate.getScenario() ;
-
-		if (currentLeg.getMode().equals("onewaycarsharing")) {
+	private void parkCSVehicle( ) {
+		Link currentLink = this.basicAgentDelegate.getScenario().getNetwork().getLinks().get( this.getCurrentLinkId() ) ;
 
+		if (this.getMode().equals("onewaycarsharing")) {
 			this.carSharingVehicles.getOneWayVehicles().addVehicle(endStationOW, owVehId);
 			owVehId = null;
-		}
-		else if (currentLeg.getMode().equals("twowaycarsharing") 
-				//				&& plan.getPlanElements().get(currentPlanElementIndex + 1) instanceof Leg
-				&& this.basicAgentDelegate.getNextPlanElement() instanceof Leg
-				) {
-
-			this.carSharingVehicles.getTwoWayVehicles().addVehicle(scenario.getNetwork().getLinks().get(this.getDestinationLinkId()), twVehId);
+		} else if (this.getMode().equals("twowaycarsharing")  && this.basicAgentDelegate.getNextPlanElement() instanceof Leg ) {
+			// park vehicle on current link (no parking capacity constraints):
+//			this.carSharingVehicles.getTwoWayVehicles().addVehicle(scenario.getNetwork().getLinks().get(this.getDestinationLinkId()), twVehId);
+			this.carSharingVehicles.getTwoWayVehicles().addVehicle( currentLink, twVehId);
 			twVehId = null;
-		}
-		else if (currentLeg.getMode().equals("freefloating")) {
+		} else if (this.getMode().equals("freefloating")) {
+			// park vehicle on current link (no parking capacity constraints):
+			this.carSharingVehicles.getFreeFLoatingVehicles().addVehicle( currentLink, ffVehId);
 
-			this.carSharingVehicles.getFreeFLoatingVehicles().addVehicle(scenario.getNetwork().getLinks().get(this.getDestinationLinkId()), ffVehId);
 			ffVehId = null;
 		}
 
@@ -231,7 +226,7 @@ public class CarsharingPersonDriverAgentImpl implements MobsimDriverAgent, Mobsi
 			}
 			else if (previousPlanElement instanceof Leg) {
 
-				initializeOneWayCarsharingEndWalkLeg(leg, now);
+				initializeOneWayCarsharingEndWalkLeg(leg);
 
 			}				
 			break;
@@ -475,10 +470,9 @@ public class CarsharingPersonDriverAgentImpl implements MobsimDriverAgent, Mobsi
 		}
 
 	}
-	private void initializeOneWayCarsharingEndWalkLeg(Leg leg, double now) {
+	private void initializeOneWayCarsharingEndWalkLeg(Leg leg) {
 		Route route = leg.getRoute();		
 		initializeCSWalkLeg(endStationOW.getLink(), this.basicAgentDelegate.getScenario().getNetwork().getLinks().get(route.getEndLinkId()));
-
 	}
 
 	private OneWayCarsharingStation findClosestAvailableOWCar(Id<Link> linkId) {
diff --git a/contribs/carsharing/src/main/java/org/matsim/contrib/carsharing/qsim/CarsharingQsimFactory.java b/contribs/carsharing/src/main/java/org/matsim/contrib/carsharing/qsim/CarsharingQsimFactory.java
index 0cd1b0e..90fb995 100644
--- a/contribs/carsharing/src/main/java/org/matsim/contrib/carsharing/qsim/CarsharingQsimFactory.java
+++ b/contribs/carsharing/src/main/java/org/matsim/contrib/carsharing/qsim/CarsharingQsimFactory.java
@@ -30,7 +30,7 @@ public class CarsharingQsimFactory implements Provider<Netsim>{
 	private final Scenario sc;
 	private final Provider<TripRouter> tripRouterProvider;	
 	private final EventsManager eventsManager;
-	
+
 	private CarSharingVehicles carSharingVehicles;
 
 	@Inject	
@@ -44,52 +44,52 @@ public class CarsharingQsimFactory implements Provider<Netsim>{
 
 	@Override
 	public Netsim get() {
-		
+
 		QSimConfigGroup conf = sc.getConfig().qsim();
 		if (conf == null) {
 			throw new NullPointerException("There is no configuration set for the QSim. Please add the module 'qsim' to your config file.");
 		}
 
 		QSim qSim = new QSim(sc, eventsManager);
-		
+
 		ActivityEngine activityEngine = new ActivityEngine(eventsManager, qSim.getAgentCounter());
 		qSim.addMobsimEngine(activityEngine);
 		qSim.addActivityHandler(activityEngine);
 
 
-        QNetsimEngineModule.configure(qSim);
-		
+		QNetsimEngineModule.configure(qSim);
+
 		TeleportationEngine teleportationEngine = new TeleportationEngine(sc, eventsManager);
 		qSim.addMobsimEngine(teleportationEngine);
-				
+
 		AgentFactory agentFactory = null;			
-			
+
 		try {
 			carSharingVehicles = new CarSharingVehicles(sc);
-		//added part
-		//a simple way to place vehicles at the original location at the start of each simulation
-		this.carSharingVehicles.readVehicleLocations();
-				
-		agentFactory = new CarsharingAgentFactory(qSim, sc, tripRouterProvider, this.carSharingVehicles);
-		
-		
-		
-		if (sc.getConfig().network().isTimeVariantNetwork()) {
-			qSim.addMobsimEngine(new NetworkChangeEventsEngine());		
-		}
-		PopulationAgentSource agentSource = new PopulationAgentSource(sc.getPopulation(), agentFactory, qSim);
-		
-		//we need to park carsharing vehicles on the network
-		ParkCSVehicles parkSource = new ParkCSVehicles(sc.getPopulation(), agentFactory, qSim,
-				this.carSharingVehicles.getFreeFLoatingVehicles(), this.carSharingVehicles.getOneWayVehicles(), this.carSharingVehicles.getTwoWayVehicles());
-		qSim.addAgentSource(agentSource);
-		qSim.addAgentSource(parkSource);
+			//added part
+			//a simple way to place vehicles at the original location at the start of each simulation
+			this.carSharingVehicles.readVehicleLocations();
+
+			agentFactory = new CarsharingAgentFactory(qSim, tripRouterProvider, this.carSharingVehicles);
+
+
+
+			if (sc.getConfig().network().isTimeVariantNetwork()) {
+				qSim.addMobsimEngine(new NetworkChangeEventsEngine());		
+			}
+			PopulationAgentSource agentSource = new PopulationAgentSource(sc.getPopulation(), agentFactory, qSim);
+
+			//we need to park carsharing vehicles on the network
+			ParkCSVehicles parkSource = new ParkCSVehicles(sc.getPopulation(), agentFactory, qSim,
+					this.carSharingVehicles.getFreeFLoatingVehicles(), this.carSharingVehicles.getOneWayVehicles(), this.carSharingVehicles.getTwoWayVehicles());
+			qSim.addAgentSource(agentSource);
+			qSim.addAgentSource(parkSource);
 		} catch (IOException e) {
 			// TODO Auto-generated catch block
 			e.printStackTrace();
 		}
-		
+
 		return qSim;
 	}
-		
+
 }
diff --git a/contribs/parking/src/main/java/org/matsim/contrib/parking/PC2/simulation/ParkingInfrastructureManager.java b/contribs/parking/src/main/java/org/matsim/contrib/parking/PC2/simulation/ParkingInfrastructureManager.java
index 0b9f579..916090d 100644
--- a/contribs/parking/src/main/java/org/matsim/contrib/parking/PC2/simulation/ParkingInfrastructureManager.java
+++ b/contribs/parking/src/main/java/org/matsim/contrib/parking/PC2/simulation/ParkingInfrastructureManager.java
@@ -308,6 +308,8 @@ public final class ParkingInfrastructureManager {
 	}
 
 	public synchronized void unParkVehicle(PC2Parking parking, double departureTime, Id<Person> personId) {
+		// yyyyyy should be private, for reasons discussed below. kai, jul'15
+		
 		// yy this design feels a bit incomplete to me.  personCarDepartureEvent removes the vehicle (by personId) from the
 		// parked vehicle data structure; the method here just does general counting.  Some code calls unParkVehicle directly, 
 		// thus bypassing the parkedVehicle data structure.  Very unphysical behavior, thus I do not like it.  kai, jul'15 
-- 
2.3.2 (Apple Git-55)

