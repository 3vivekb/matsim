From 6722ced3cda50c71fd3467bcfa64c1980d095250 Mon Sep 17 00:00:00 2001
From: Kai Nagel <2008@kainagel.org>
Date: Thu, 23 Jul 2015 18:09:38 +0100
Subject: [PATCH 12/16] parking maintenance

---
 .../contribs/parking/PC2/GeneralParkingModule.java  |   3 +-
 .../PC2/simulation/ParkingArrivalEvent.java        |   2 +
 .../PC2/simulation/ParkingChoiceSimulation.java    | 223 +++++++--------------
 .../simulation/ParkingInfrastructureManager.java   |  43 +++-
 .../matsim/core/population/PopulationUtils.java    |  61 ++++++
 5 files changed, 171 insertions(+), 161 deletions(-)

diff --git a/contribs/parking/src/main/java/org/matsim/contrib/parking/PC2/GeneralParkingModule.java b/contribs/parking/src/main/java/org/matsim/contrib/parking/PC2/GeneralParkingModule.java
index 9bf68ba..bce63eb 100644
--- a/contribs/parking/src/main/java/org/matsim/contrib/parking/PC2/GeneralParkingModule.java
+++ b/contribs/parking/src/main/java/org/matsim/contrib/parking/PC2/GeneralParkingModule.java
@@ -38,7 +38,8 @@ public class GeneralParkingModule implements StartupListener, IterationStartsLis
 	public void notifyStartup(StartupEvent event) {
 		parkingSimulation = new ParkingChoiceSimulation(controler, parkingInfrastructureManager);
 		controler.getEvents().addHandler(parkingSimulation);
-		controler.addControlerListener(parkingSimulation);
+//		controler.addControlerListener(parkingSimulation);
+		// was not doing anything there. kai, jul'15
 	}
 
 	@Override
diff --git a/contribs/parking/src/main/java/org/matsim/contrib/parking/PC2/simulation/ParkingArrivalEvent.java b/contribs/parking/src/main/java/org/matsim/contrib/parking/PC2/simulation/ParkingArrivalEvent.java
index 614c8df..887be23 100644
--- a/contribs/parking/src/main/java/org/matsim/contrib/parking/PC2/simulation/ParkingArrivalEvent.java
+++ b/contribs/parking/src/main/java/org/matsim/contrib/parking/PC2/simulation/ParkingArrivalEvent.java
@@ -41,6 +41,8 @@ public class ParkingArrivalEvent extends Event {
 	private Coord destCoordinate;
 	private double score;
 	
+	// yyyyyy the parking arrival event returns person id, not vehicle id.  Do we change to vehicle id, or add the vehicle
+	// id to the event?  It is used for the walk distance; for that we need the person id. kai, jul'15
 
 	public ParkingArrivalEvent(double time, Id parkingId, Id personId, Coord destCoordinate, double score) {
 		super(time);
diff --git a/contribs/parking/src/main/java/org/matsim/contrib/parking/PC2/simulation/ParkingChoiceSimulation.java b/contribs/parking/src/main/java/org/matsim/contrib/parking/PC2/simulation/ParkingChoiceSimulation.java
index b6278f4..d3c83fc 100644
--- a/contribs/parking/src/main/java/org/matsim/contrib/parking/PC2/simulation/ParkingChoiceSimulation.java
+++ b/contribs/parking/src/main/java/org/matsim/contrib/parking/PC2/simulation/ParkingChoiceSimulation.java
@@ -19,19 +19,21 @@
 
 package org.matsim.contrib.parking.PC2.simulation;
 
+import java.util.HashMap;
+import java.util.List;
+
 import org.matsim.api.core.v01.Id;
 import org.matsim.api.core.v01.TransportMode;
 import org.matsim.api.core.v01.events.ActivityEndEvent;
-import org.matsim.api.core.v01.events.ActivityStartEvent;
 import org.matsim.api.core.v01.events.PersonArrivalEvent;
 import org.matsim.api.core.v01.events.PersonDepartureEvent;
 import org.matsim.api.core.v01.events.handler.ActivityEndEventHandler;
-import org.matsim.api.core.v01.events.handler.ActivityStartEventHandler;
 import org.matsim.api.core.v01.events.handler.PersonArrivalEventHandler;
 import org.matsim.api.core.v01.events.handler.PersonDepartureEventHandler;
 import org.matsim.api.core.v01.network.Link;
+import org.matsim.api.core.v01.population.Activity;
+import org.matsim.api.core.v01.population.Leg;
 import org.matsim.api.core.v01.population.Person;
-import org.matsim.api.core.v01.population.Plan;
 import org.matsim.api.core.v01.population.PlanElement;
 import org.matsim.contrib.parking.PC2.infrastructure.PC2Parking;
 import org.matsim.contrib.parking.lib.DebugLib;
@@ -39,97 +41,26 @@ import org.matsim.contrib.parking.lib.GeneralLib;
 import org.matsim.contrib.parking.lib.obj.DoubleValueHashMap;
 import org.matsim.contrib.parking.lib.obj.IntegerValueHashMap;
 import org.matsim.core.controler.Controler;
-import org.matsim.core.controler.events.BeforeMobsimEvent;
-import org.matsim.core.controler.listener.BeforeMobsimListener;
-import org.matsim.core.population.ActivityImpl;
-import org.matsim.core.population.LegImpl;
+import org.matsim.core.population.PopulationUtils;
 
-import java.util.HashMap;
-import java.util.List;
-
-public class ParkingChoiceSimulation implements PersonDepartureEventHandler, ActivityStartEventHandler, PersonArrivalEventHandler, ActivityEndEventHandler, BeforeMobsimListener {
+public final class ParkingChoiceSimulation implements PersonDepartureEventHandler, PersonArrivalEventHandler, 
+ActivityEndEventHandler {
 
 	private ParkingInfrastructureManager parkingInfrastructureManager;
 	private Controler controler;
-	IntegerValueHashMap<Id> currentPlanElementIndex;
-	HashMap<Id, ParkingOperationRequestAttributes> parkingOperationRequestAttributes;
-	DoubleValueHashMap<Id> firstDepartureTimeOfDay;
+	private IntegerValueHashMap<Id<Person>> currentPlanElementIndex;
+	private HashMap<Id<Person>, ParkingOperationRequestAttributes> parkingOperationRequestAttributes;
+	private DoubleValueHashMap<Id<Person>> firstDepartureTimeOfDay;
 
 	public ParkingChoiceSimulation(Controler controler, ParkingInfrastructureManager parkingInfrastructureManager){
 		this.controler = controler;
 		this.parkingInfrastructureManager = parkingInfrastructureManager;
 	}
-	
+
 	@Override
 	public void reset(int iteration) {
 		DebugLib.emptyFunctionForSettingBreakPoint();
 	}
-	
-	public ActivityImpl getFirstActivityAfterLastCarLegOfDay(Plan plan){
-		List<PlanElement> planElements = plan.getPlanElements();
-		int indexOfLastCarLegOfDay=-1;
-		for (int i=planElements.size()-1;i>=0;i--){
-			if (planElements.get(i) instanceof LegImpl){
-				LegImpl Leg= (LegImpl) planElements.get(i);
-				
-				if (Leg.getMode().equalsIgnoreCase(TransportMode.car)){
-					indexOfLastCarLegOfDay=i;
-					break;
-				}
-				
-			}
-		}
-		
-		for (int i=indexOfLastCarLegOfDay+1;i<planElements.size();i++){
-			if (planElements.get(i) instanceof ActivityImpl){
-				return (ActivityImpl) planElements.get(i);
-			}
-		}
-		return null;
-	}
-	
-	public ActivityImpl getFirstActivityOfDayBeforeDepartingWithCar(Plan plan){
-		List<PlanElement> planElements = plan.getPlanElements();
-		int indexOfFirstCarLegOfDay=-1;
-		for (int i=0;i<planElements.size();i++){
-			if (planElements.get(i) instanceof LegImpl){
-				LegImpl Leg= (LegImpl) planElements.get(i);
-				
-				if (Leg.getMode().equalsIgnoreCase(TransportMode.car)){
-					indexOfFirstCarLegOfDay=i;
-					break;
-				}
-				
-			}
-		}
-		for (int i=indexOfFirstCarLegOfDay-1;i>=0;i--){
-			if (planElements.get(i) instanceof ActivityImpl){
-				return (ActivityImpl) planElements.get(i);
-			}
-		}
-		return null;
-	}
-	
-	public boolean hasCarLeg(Plan plan){
-		List<PlanElement> planElements = plan.getPlanElements();
-		for (int i=0;i<planElements.size();i++){
-			if (planElements.get(i) instanceof LegImpl){
-				LegImpl Leg= (LegImpl) planElements.get(i);
-				
-				if (Leg.getMode().equalsIgnoreCase(TransportMode.car)){
-					return true;
-				}
-				
-			}
-		}
-		return false;
-	}
-	
-
-	@Override
-	public void handleEvent(ActivityStartEvent event) {
-		
-	}
 
 	@Override
 	public void handleEvent(PersonDepartureEvent event) {
@@ -137,8 +68,7 @@ public class ParkingChoiceSimulation implements PersonDepartureEventHandler, Act
 			if (!firstDepartureTimeOfDay.containsKey(event.getPersonId())){
 				firstDepartureTimeOfDay.put(event.getPersonId(),event.getTime());
 			}
-			
-			
+
 			if (isFirstCarDepartureOfDay(event.getPersonId())){
 				DebugLib.emptyFunctionForSettingBreakPoint();
 				ParkingOperationRequestAttributes parkingAttributes = new ParkingOperationRequestAttributes();
@@ -153,26 +83,25 @@ public class ParkingChoiceSimulation implements PersonDepartureEventHandler, Act
 				if (parkingAttributes.parkingDurationInSeconds==24*3600){
 					parkingAttributes.parkingDurationInSeconds=1; // not zero, because this might lead to NaN
 				}
-				
+
 				PC2Parking parking = parkingInfrastructureManager.personCarDepartureEvent(parkingAttributes);
 				parkingInfrastructureManager.scoreParkingOperation(parkingAttributes,parking);
 			}
-			
-			
+
 		}
 	}
 
-	private boolean isFirstCarDepartureOfDay(Id personId) {
-        Person person = controler.getScenario().getPopulation().getPersons().get(personId);
+	private boolean isFirstCarDepartureOfDay(Id<Person> personId) {
+		Person person = controler.getScenario().getPopulation().getPersons().get(personId);
 		List<PlanElement> planElements = person.getSelectedPlan().getPlanElements();
 		for (int i=currentPlanElementIndex.get(personId)-1;i>=0;i--){
-			if (planElements.get(i) instanceof LegImpl){
-				LegImpl Leg= (LegImpl) planElements.get(i);
-				
-				if (Leg.getMode().equalsIgnoreCase(TransportMode.car)){
+			if (planElements.get(i) instanceof Leg){
+				Leg leg= (Leg) planElements.get(i);
+
+				if (leg.getMode().equalsIgnoreCase(TransportMode.car)){
 					return false;
 				}
-				
+
 			}
 		}
 		return true;
@@ -185,128 +114,124 @@ public class ParkingChoiceSimulation implements PersonDepartureEventHandler, Act
 
 	@Override
 	public void handleEvent(PersonArrivalEvent event) {
-		Id personId = event.getPersonId();
+		Id<Person> personId = event.getPersonId();
 		if (event.getLegMode().equalsIgnoreCase(TransportMode.car)){
 			ParkingOperationRequestAttributes parkingAttributes =new ParkingOperationRequestAttributes();
-            Link link = controler.getScenario().getNetwork().getLinks().get(event.getLinkId());
-			ActivityImpl nextActivity = getNextActivity(personId);
-			
+			Link link = controler.getScenario().getNetwork().getLinks().get(event.getLinkId());
+			Activity nextActivity = getNextActivity(personId);
+
 			parkingAttributes.destCoordinate=link.getCoord();
 			parkingAttributes.arrivalTime=event.getTime();
 			parkingAttributes.personId=personId;
 			parkingAttributes.facilityId=nextActivity.getFacilityId();
 			parkingAttributes.actType=nextActivity.getType();
-			
+
 			if (isLastCarLegOfDay(personId)){
 				parkingAttributes.parkingDurationInSeconds=GeneralLib.getIntervalDuration(event.getTime(), firstDepartureTimeOfDay.get(personId));
-				
+
 			} else {
-				ActivityImpl activityBeforeNextCarLeg = getActivityBeforeNextCarLeg(personId);
+				Activity activityBeforeNextCarLeg = getActivityBeforeNextCarLeg(personId);
 				parkingAttributes.parkingDurationInSeconds=GeneralLib.getIntervalDuration(event.getTime(), activityBeforeNextCarLeg.getEndTime());
 			}
-			
+
 			parkingAttributes.legIndex=currentPlanElementIndex.get(personId);
-			
+
 			PC2Parking parking = parkingInfrastructureManager.parkVehicle(parkingAttributes);
-			
+			// to me this looks like first the agent arrives at his/her activity.  And then the negative parking score is added after the
+			// fact, however without consuming time.  I.e. there is no physics.  kai, jul'15
+
 			if (isLastCarLegOfDay(personId)){
 				parkingInfrastructureManager.scoreParkingOperation(parkingAttributes,parking);
 			}
-			
+
 			parkingOperationRequestAttributes.put(personId, parkingAttributes);
-			
+
 		}
-		
-		
-		
+
 		currentPlanElementIndex.increment(personId);
 	}
-	
+
 	// TODO: operation could be made faster through caching.
-	private boolean isLastCarLegOfDay(Id personId){
-        Person person = controler.getScenario().getPopulation().getPersons().get(personId);
+	private boolean isLastCarLegOfDay(Id<Person> personId){
+		Person person = controler.getScenario().getPopulation().getPersons().get(personId);
 		List<PlanElement> planElements = person.getSelectedPlan().getPlanElements();
 		for (int i=currentPlanElementIndex.get(personId)+1;i<planElements.size();i++){
-			if (planElements.get(i) instanceof LegImpl){
-				LegImpl Leg= (LegImpl) planElements.get(i);
-				
+			if (planElements.get(i) instanceof Leg){
+				Leg Leg= (Leg) planElements.get(i);
+
 				if (Leg.getMode().equalsIgnoreCase(TransportMode.car)){
 					return false;
 				}
-				
+
 			}
 		}
 		return true;
 	}
-	
-	private ActivityImpl getActivityBeforeNextCarLeg(Id personId){
-        Person person = controler.getScenario().getPopulation().getPersons().get(personId);
+
+	private Activity getActivityBeforeNextCarLeg(Id<Person> personId){
+		Person person = controler.getScenario().getPopulation().getPersons().get(personId);
 		List<PlanElement> planElements = person.getSelectedPlan().getPlanElements();
 		int indexOfNextCarLeg=-1;
 		for (int i=currentPlanElementIndex.get(personId)+1;i<planElements.size();i++){
-			if (planElements.get(i) instanceof LegImpl){
-				LegImpl Leg= (LegImpl) planElements.get(i);
-				
+			if (planElements.get(i) instanceof Leg){
+				Leg Leg= (Leg) planElements.get(i);
+
 				if (Leg.getMode().equalsIgnoreCase(TransportMode.car)){
 					indexOfNextCarLeg=i;
 					break;
 				}
-				
+
 			}
 		}
-		
+
 		for (int i=indexOfNextCarLeg-1;i>=0;i--){
-			if (planElements.get(i) instanceof ActivityImpl){
-				return (ActivityImpl) planElements.get(i);
+			if (planElements.get(i) instanceof Activity){
+				return (Activity) planElements.get(i);
 			}
 		}
-		
+
 		return null;
 	}
-	
-	private ActivityImpl getNextActivity(Id personId){
-        Person person = controler.getScenario().getPopulation().getPersons().get(personId);
+
+	private Activity getNextActivity(Id<Person> personId){
+		Person person = controler.getScenario().getPopulation().getPersons().get(personId);
 		List<PlanElement> planElements = person.getSelectedPlan().getPlanElements();
 		for (int i=currentPlanElementIndex.get(personId);i<planElements.size();i++){
-			if (planElements.get(i) instanceof ActivityImpl){
-				return (ActivityImpl) planElements.get(i);
+			if (planElements.get(i) instanceof Activity){
+				return (Activity) planElements.get(i);
 			}
 		}
 		return null;
 	}
 
 	public void prepareForNewIteration() {
-		currentPlanElementIndex=new IntegerValueHashMap<Id>();
-		parkingOperationRequestAttributes=new HashMap<Id, ParkingOperationRequestAttributes>();
-		firstDepartureTimeOfDay=new DoubleValueHashMap<Id>();
+		currentPlanElementIndex=new IntegerValueHashMap<>();
+		parkingOperationRequestAttributes=new HashMap<>();
+		firstDepartureTimeOfDay=new DoubleValueHashMap<>();
 
-        for (Person person: controler.getScenario().getPopulation().getPersons().values()){
-			if (hasCarLeg(person.getSelectedPlan())){
+		for (Person person: controler.getScenario().getPopulation().getPersons().values()){
+			if (PopulationUtils.hasCarLeg(person.getSelectedPlan())){
 				DebugLib.traceAgent(person.getId());
 				ParkingOperationRequestAttributes parkingAttributes = new ParkingOperationRequestAttributes();
-				
-				ActivityImpl firstActivityOfDayBeforeDepartingWithCar = getFirstActivityOfDayBeforeDepartingWithCar(person.getSelectedPlan());
-				ActivityImpl firstActivityAfterLastCarLegOfDay = getFirstActivityAfterLastCarLegOfDay(person.getSelectedPlan());
-				
+
+				Activity firstActivityOfDayBeforeDepartingWithCar = PopulationUtils.getFirstActivityOfDayBeforeDepartingWithCar(person.getSelectedPlan());
+				Activity firstActivityAfterLastCarLegOfDay = PopulationUtils.getFirstActivityAfterLastCarLegOfDay(person.getSelectedPlan());
+
 				parkingAttributes.destCoordinate=firstActivityAfterLastCarLegOfDay.getCoord();
 				//parkingAttributes.arrivalTime=firstActivityAfterLastCarLegOfDay.getStartTime();
 				parkingAttributes.arrivalTime=0;
-				
+
 				parkingAttributes.personId=person.getId();
 				parkingAttributes.facilityId=firstActivityAfterLastCarLegOfDay.getFacilityId();
 				parkingAttributes.actType=firstActivityAfterLastCarLegOfDay.getType();
-				parkingAttributes.parkingDurationInSeconds=GeneralLib.getIntervalDuration(firstActivityAfterLastCarLegOfDay.getStartTime(), firstActivityOfDayBeforeDepartingWithCar.getEndTime());
-				
+				parkingAttributes.parkingDurationInSeconds=GeneralLib.getIntervalDuration(firstActivityAfterLastCarLegOfDay.getStartTime(), 
+						firstActivityOfDayBeforeDepartingWithCar.getEndTime());
+
 				parkingAttributes.legIndex=0;
-				
+
 				parkingInfrastructureManager.parkVehicle(parkingAttributes);
 			}
 		}
 	}
 
-	@Override
-	public void notifyBeforeMobsim(BeforeMobsimEvent event) {
-		DebugLib.emptyFunctionForSettingBreakPoint();
-	}
-	
 }
diff --git a/contribs/parking/src/main/java/org/matsim/contrib/parking/PC2/simulation/ParkingInfrastructureManager.java b/contribs/parking/src/main/java/org/matsim/contrib/parking/PC2/simulation/ParkingInfrastructureManager.java
index c267a9d..bbf6a10 100644
--- a/contribs/parking/src/main/java/org/matsim/contrib/parking/PC2/simulation/ParkingInfrastructureManager.java
+++ b/contribs/parking/src/main/java/org/matsim/contrib/parking/PC2/simulation/ParkingInfrastructureManager.java
@@ -44,12 +44,8 @@ import org.matsim.facilities.ActivityFacility;
 public class ParkingInfrastructureManager {
 
 	private ParkingScoreManager parkingScoreManager;
-
 	private HashMap<Id<PC2Parking>, PC2Parking> allParkings;
-
-	// personId, parkingFacilityId
 	private HashMap<Id<Person>, Id<PC2Parking>> parkedVehicles;
-
 	private EventsManager eventsManager;
 
 	// facilityId -> parkings available to users of that facility
@@ -120,14 +116,16 @@ public class ParkingInfrastructureManager {
 	public synchronized void reset() {
 		parkedVehicles.clear();
 
-		for (Id<PC2Parking> parkingFacilityId : getAllParkings().keySet()) {
-			PC2Parking parking = getAllParkings().get(parkingFacilityId);
+		for ( PC2Parking parking : getAllParkings().values() ) {
 			if (parking.getAvailableParkingCapacity() == 0) {
-				// I have no idea what this is doing and why.  Why should parking be full at the end of simulation?  Why put it 
+				// yyyyyy I have no idea what this is doing and why.  Why should parking be full at the end of simulation?  Why put it 
 				// into a quad tree?  Maybe this is an implicit marker that has been added during the previous iteration??? kai, jul'15
 				if (!(parking instanceof PrivateParking)) {
 					addParkingToQuadTree(publicParkingsQuadTree, parking);
 					addParkingToQuadTree(publicParkingGroupQuadTrees.get(parking.getGroupName()), parking);
+					// yyyyyy I could speculate that full parking lots are removed from the quad tree, and it is re-added as soon
+					// as space becomes available.  But this is not commented, and it also does not look like it would work in that way.
+					// kai, jul'15
 				}
 			}
 			parking.resetAvailability();
@@ -188,22 +186,32 @@ public class ParkingInfrastructureManager {
 
 		PC2Parking selectedParking = null;
 		boolean parkingFound = false;
+		
+		// first search for parking at selected facility:
 		for (PPRestrictedToFacilities pp : privateParkingsRestrictedToFacilities.get(parkingOperationRequestAttributes.facilityId)) {
 			if (pp.getAvailableParkingCapacity() > 0) {
+
+				// this tells the parking lot to decrease the number of available spaces:
 				pp.parkVehicle();
+
+				// this puts the personId (!!!! yyyyyy) at the parking location:
 				parkedVehicles.put(parkingOperationRequestAttributes.personId, pp.getId());
+				
 				parkingFound = true;
 				selectedParking = pp;
 			}
 		}
 
+		// if not found, search within distance of 300m:
 		double distance = 300;
 		if (!parkingFound) {
 			Collection<PC2Parking> collection = getPublicParkingQuadTree().get(
 					parkingOperationRequestAttributes.destCoordinate.getX(),
 					parkingOperationRequestAttributes.destCoordinate.getY(), distance);
 
-			if (!parkingFound) {
+			if (!parkingFound) { 
+				// yyyyyy no idea why the condition is checked again but it is certainly still valid.  
+				
 				while (collection.size() == 0) {
 					distance *= 2;
 					collection = getPublicParkingQuadTree().get(parkingOperationRequestAttributes.destCoordinate.getX(),
@@ -216,8 +224,8 @@ public class ParkingInfrastructureManager {
 
 				}
 
+				// put parking that was found into a sorted queue:
 				PriorityQueue<SortableMapObject<PC2Parking>> queue = new PriorityQueue<SortableMapObject<PC2Parking>>();
-
 				for (PC2Parking parking : collection) {
 					double score = parkingScoreManager.calcScore(parkingOperationRequestAttributes.destCoordinate,
 							parkingOperationRequestAttributes.arrivalTime,
@@ -228,11 +236,15 @@ public class ParkingInfrastructureManager {
 
 				// TODO: should I make MNL only on top 5 here?
 
+				// select the best one from the queue:
 				SortableMapObject<PC2Parking> poll = queue.peek();
 				finalScore = poll.getScore();
 				selectedParking = poll.getKey();
+
+				// this puts the personId (!!!! yyyyyy) at the parking location:
 				parkedVehicles.put(parkingOperationRequestAttributes.personId, selectedParking.getId());
 
+				// this tells the parking lot to decrease the number of available spaces:
 				parkVehicle(selectedParking);
 
 //				PC2Parking closestParking = getPublicParkingQuadTree().get(parkingOperationRequestAttributes.destCoordinate.getX(),
@@ -282,6 +294,8 @@ public class ParkingInfrastructureManager {
 
 		eventsManager.processEvent(new ParkingArrivalEvent(parkingOperationRequestAttributes.arrivalTime, selectedParking.getId(),
 				parkingOperationRequestAttributes.personId, parkingOperationRequestAttributes.destCoordinate, finalScore));
+		// yyyyyy the parking arrival event returns person id, not vehicle id.  Do we change to vehicle id, or add the vehicle
+		// id to the event?  In the code, the person id is used for the walk distance. kai, jul'15
 
 		return selectedParking;
 	}
@@ -323,11 +337,15 @@ public class ParkingInfrastructureManager {
 				DebugLib.stopSystemAndReportInconsistency(parking.getId().toString());
 			}
 
-			Collection<PC2Parking> collection = publicParkingsQuadTree.get(parking.getCoordinate().getX(), parking.getCoordinate()
-					.getY(), 1);
+			Collection<PC2Parking> collection = publicParkingsQuadTree.get(parking.getCoordinate().getX(), parking.getCoordinate().getY(), 1);
 			if (collection.size() == 1) {
 				for (PC2Parking p : collection) {
+					// yyyyyy no idea why we first test for "size of collection == 1" and then iterate over it.  kai, jul'15
+					
 					if (p.getId().toString().equalsIgnoreCase(parking.getId().toString())) {
+						// (i.e. the found parking is not the same as the one that should be at the coordinate; two parking locations are
+						// on top of each other)
+						
 						DebugLib.stopSystemAndReportInconsistency();
 					}
 				}
@@ -381,6 +399,9 @@ public class ParkingInfrastructureManager {
 			if (!(parking instanceof PrivateParking)) {
 				addParkingToQuadTree(publicParkingsQuadTree, parking);
 				addParkingToQuadTree(publicParkingGroupQuadTrees.get(parking.getGroupName()), parking);
+				// yyyyyy I could speculate that full parking lots are removed from the quad tree, and it is re-added as soon
+				// as space becomes available.  But this is not commented, and it also does not look like it would work in that way.
+				// kai, jul'15
 			}
 		}
 
diff --git a/matsim/src/main/java/org/matsim/core/population/PopulationUtils.java b/matsim/src/main/java/org/matsim/core/population/PopulationUtils.java
index 993ea67..cee7813 100644
--- a/matsim/src/main/java/org/matsim/core/population/PopulationUtils.java
+++ b/matsim/src/main/java/org/matsim/core/population/PopulationUtils.java
@@ -22,6 +22,7 @@ package org.matsim.core.population;
 
 import org.matsim.api.core.v01.Coord;
 import org.matsim.api.core.v01.Id;
+import org.matsim.api.core.v01.TransportMode;
 import org.matsim.api.core.v01.network.Link;
 import org.matsim.api.core.v01.network.Network;
 import org.matsim.api.core.v01.population.*;
@@ -516,5 +517,65 @@ public final class PopulationUtils {
 			throw new UncheckedIOException(e);
 		}
 	}
+
+	public static Activity getFirstActivityAfterLastCarLegOfDay(Plan plan){
+		List<PlanElement> planElements = plan.getPlanElements();
+		int indexOfLastCarLegOfDay=-1;
+		for (int i=planElements.size()-1;i>=0;i--){
+			if (planElements.get(i) instanceof Leg){
+				Leg leg = (Leg) planElements.get(i);
+	
+				if (leg.getMode().equalsIgnoreCase(TransportMode.car)){
+					indexOfLastCarLegOfDay=i;
+					break;
+				}
+	
+			}
+		}
+	
+		for (int i=indexOfLastCarLegOfDay+1;i<planElements.size();i++){
+			if (planElements.get(i) instanceof Activity){
+				return (Activity) planElements.get(i);
+			}
+		}
+		return null;
+	}
+
+	public static Activity getFirstActivityOfDayBeforeDepartingWithCar(Plan plan){
+		List<PlanElement> planElements = plan.getPlanElements();
+		int indexOfFirstCarLegOfDay=-1;
+		for (int i=0;i<planElements.size();i++){
+			if (planElements.get(i) instanceof Leg){
+				Leg leg= (Leg) planElements.get(i);
+	
+				if (leg.getMode().equalsIgnoreCase(TransportMode.car)){
+					indexOfFirstCarLegOfDay=i;
+					break;
+				}
+	
+			}
+		}
+		for (int i=indexOfFirstCarLegOfDay-1;i>=0;i--){
+			if (planElements.get(i) instanceof Activity){
+				return (Activity) planElements.get(i);
+			}
+		}
+		return null;
+	}
+
+	public static boolean hasCarLeg(Plan plan){
+		List<PlanElement> planElements = plan.getPlanElements();
+		for (int i=0;i<planElements.size();i++){
+			if (planElements.get(i) instanceof Leg){
+				Leg Leg= (Leg) planElements.get(i);
+	
+				if (Leg.getMode().equalsIgnoreCase(TransportMode.car)){
+					return true;
+				}
+	
+			}
+		}
+		return false;
+	}
 	
 }
-- 
2.3.2 (Apple Git-55)

