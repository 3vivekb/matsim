/* *********************************************************************** *
 * project: org.matsim.*
 * SNController02.java
 *                                                                         *
 * *********************************************************************** *
 *                                                                         *
 * copyright       : (C) 2007 by the members listed in the COPYING,        *
 *                   LICENSE and WARRANTY file.                            *
 * email           : info at matsim dot org                                *
 *                                                                         *
 * *********************************************************************** *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *   See also COPYING, LICENSE and WARRANTY file                           *
 *                                                                         *
 * *********************************************************************** */

package playground.jhackney.run;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;

import org.matsim.analysis.CalcLegTimes;
import org.matsim.analysis.CalcLinkStats;
import org.matsim.analysis.VolumesAnalyzer;
import org.matsim.config.Config;
import org.matsim.config.ConfigWriter;
import org.matsim.controler.IterationCleanup;
import org.matsim.events.Events;
import org.matsim.events.algorithms.EventWriterTXT;
import org.matsim.events.algorithms.TravelTimeCalculator;
import org.matsim.events.handler.EventHandlerI;
import org.matsim.facilities.Facilities;
import org.matsim.facilities.FacilitiesWriter;
import org.matsim.facilities.MatsimFacilitiesReader;
import org.matsim.gbl.Gbl;
import org.matsim.mobsim.ExternalMobsim;
import org.matsim.mobsim.QueueNetworkLayer;
import org.matsim.mobsim.QueueSimulation;
import org.matsim.mobsim.Simulation;
import org.matsim.mobsim.SimulationTimer;
import org.matsim.network.MatsimNetworkReader;
import org.matsim.network.NetworkLayer;
import org.matsim.network.NetworkLayerBuilder;
import org.matsim.network.NetworkWriter;
import org.matsim.planomat.PlanomatControler;
import org.matsim.planomat.PlanomatStrategyManagerConfigLoader;
import org.matsim.planomat.costestimators.DepartureDelayAverageCalculator;
import org.matsim.plans.MatsimPlansReader;
import org.matsim.plans.Person;
import org.matsim.plans.Plans;
import org.matsim.plans.PlansReaderI;
import org.matsim.plans.PlansWriter;
import org.matsim.plans.algorithms.PersonPrepareForSim;
import org.matsim.plans.algorithms.PlanAverageScore;
import org.matsim.replanning.PlanStrategy;
import org.matsim.replanning.StrategyManager;
import org.matsim.replanning.selectors.BestPlanSelector;
import org.matsim.roadpricing.CalcPaidToll;
import org.matsim.roadpricing.RoadPricingReaderXMLv1;
import org.matsim.roadpricing.RoadPricingScheme;
import org.matsim.router.PlansCalcRoute;
import org.matsim.router.costcalculators.TravelTimeDistanceCostCalculator;
import org.matsim.router.util.TravelCostI;
import org.matsim.router.util.TravelTimeI;
import org.matsim.scoring.CharyparNagelScoringFunction;
import org.matsim.scoring.CharyparNagelScoringFunctionFactory;
import org.matsim.scoring.EventsToScore;
import org.matsim.world.MatsimWorldReader;
import org.matsim.world.WorldWriter;
import org.matsim.world.algorithms.WorldBottom2TopCompletion;

import playground.jhackney.algorithms.SNSecLocShortest;
import playground.jhackney.interactions.NonSpatialInteractor;
import playground.jhackney.interactions.SocializingOpportunity;
import playground.jhackney.interactions.SpatialInteractor;
import playground.jhackney.interactions.SpatialSocialOpportunityTracker;
import playground.jhackney.io.PajekNetWriterWrapper;
import playground.jhackney.io.PajekWriter1;
import playground.jhackney.replanning.SNFacilitySwitcher;
import playground.jhackney.scoring.SNScoringFunctionFactory01;
import playground.jhackney.socialnet.SocialNetwork;
import playground.jhackney.statistics.SocialNetworkStatistics;

public class SNController02 extends Controler {
	
	SocialNetwork snet;
	SocialNetworkStatistics snetstat;
	PajekWriter1 pjw;
	
	// Should be restructured to loop through Persons, not Edges
	NonSpatialInteractor plansInteractorNS;//non-spatial (not observed, ICT)
	// Should be restructured to be a loop through Persons, not SocializingOpportunities
	SpatialInteractor plansInteractorS;//spatial (face to face)
	int max_sn_iter;
	
	// Hard code this locally where it is used
	String [] infoToExchange;//type of info for non-spatial exchange is read in 
	public static String activityTypesForEncounters[]={"home","work","shop","education","leisure"};

	SpatialSocialOpportunityTracker gen2 = new SpatialSocialOpportunityTracker();
	Collection<SocializingOpportunity> socialEvents=null;

//	Variables for allocating the spatial meetings among different types of activities
	// Silly and should be hard coded where it is used
	double fractionS[];
	HashMap<String,Double> rndEncounterProbs= new HashMap<String,Double>();
	
//	New variables for replanning
	// Possible still useful, but in a totally different structure within a PlanStrategy
	int replan_interval;
	
/////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
	
	@Override
	protected void startup() {
		super.startup();
		
		System.out.println("----------Initialization of social network -------------------------------------");
		snsetup();
		System.out.println("... done");
		
	}

///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
	
	@Override
	protected loadData(){
		super.loadData();
		
		// Make sure the world is consistently mapped to the network layer

		new WorldBottom2TopCompletion().run(Gbl.getWorld());
		
		// Build the Mental Map of the agents
		System.out.println(" Initializing agent knowledge ...");
		initializeKnowledge(population);
		System.out.println("... done");
	}

///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
	
	@Override
	protected setupOutputDir(){
		super.setupOutputDir();
		
		SOCNET_OUT_DIR = outputPath + "/"+DIRECTORY_SN;
		File snDir = new File(SOCNET_OUT_DIR);
		if (!snDir.mkdir() && !snDir.exists()) {
			Gbl.errorMsg("The iterations directory " + (outputPath + "/" + DIRECTORY_SN) + " could not be created.");
		}
	}
	
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
	
	@Override
	protected void setupIterations(int iteration){
		super.setupIteration(iteration);
		
		// generate SocialOpportunities
		System.out.println("  Generating [Spatial] socializing opportunities ...");
		System.out.println("   Mapping which agents were doing what, where, and when");
		
		// Create the social opportunities from plans (updated each time plans change)
		// OK to initialize from plans but do this from events if events != null!
		socialEvents = gen2.generate(population);
		System.out.println("...finished.");
	}
	
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
	
	@Override
	protected StrategyManager loadStrategyManager() {
		StrategyManager manager = new StrategyManager();
		
//		PlanomatStrategyManagerConfigLoader.load(
//				Gbl.getConfig(), 
//				manager, 
//				network, 
//				super.travelCostCalculator, 
//				super.travelTimeCalculator, 
//				this.legTravelTimeEstimator
//		);
		
		// NOTE need a StrategyManagerConfigLoader
		// The social network must run with 100% of agents
		// The social network must run first
		// The social network strategy may exchange information
		//   or change plans somehow
		// The algorithm must be a strategy, i.e. it iterates through persons
		//   however the spatial interactions will be mapped to SocializingOpportunities.
		// The social network strategy may attempt to optimize before returning control to
		//   Controler
		// The social network strategy may use the standard utility (scoring) function or
		//   a modified one which accounts for socializing (face to face, etc.)
		// ** IT IS NOT CLEAR HOW SOCIAL LINKS MAY BE CHANGED IF MATSIM IS ITERATING THROUGH PERSONS,
		//   UNLESS PLANS/SOCIAL NETS ARE WRITTEN OUT EACH ITERATION **
		// The social network interactions can be followed by any other strategy
		//   with any desired % of agents.
		// The selector for the social network strategy may be any selector
		
		return manager;
	}
	
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////
	
	@Override
	protected finishIteration(int iteration){
		super.finishIteration(iteration);
		
		System.out.println("  Updating [Spatial] socializing opportunities to changed plans for iteration " + snIter + "...");
		socialEvents=gen2.generate(population);
		System.out.println("... finished.");
		
		//Output social network statistics each iteration
		//  The social network output has network statistics,
		//  individual statistics, combines the Events file with
		//  the Person characteristics, along with socializing data
		// Maybe this is not necessary in finishIteration, but can be done in
		//	social network PlanStrategy
	}

	
///////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////

	private void snsetup() {

//		Config config = Gbl.getConfig();

		max_sn_iter = Integer.parseInt(config.socnetmodule().getNumIterations());
		replan_interval = Integer.parseInt(config.socnetmodule().getRPInt());
		String rndEncounterProbString = config.socnetmodule().getFacWt();
		String interactorNSFacTypesString = config.socnetmodule().getXchange();
		infoToExchange = getFacTypes(interactorNSFacTypesString);
		fractionS = getActivityTypeAllocation(rndEncounterProbString);
		rndEncounterProbs = getActivityTypeAllocationMap(activityTypesForEncounters, rndEncounterProbString);

		// TODO Auto-generated method stub
		System.out.println(" Instantiating the Pajek writer ...");

		pjw = new PajekWriter1(SOCNET_OUT_DIR, facilities);
		System.out.println("... done");

		System.out.println(" Initializing the social network ...");
		snet = new SocialNetwork(population);
		System.out.println("... done");

		System.out.println(" Calculating the statistics of the initial social network)...");
		snetstat=new SocialNetworkStatistics();
		snetstat.openFiles();
		snetstat.calculate(0, snet, population);
		System.out.println(" ... done");

		System.out.println(" Writing out the initial social network ...");
		pjw.write(snet.getLinks(), population, 0);
		System.out.println("... done");

		System.out.println(" Setting up the NonSpatial interactor ...");
		plansInteractorNS=new NonSpatialInteractor(snet);
		System.out.println("... done");

		System.out.println(" Setting up the Spatial interactor ...");
		plansInteractorS=new SpatialInteractor(snet);
		System.out.println("... done");
	}
}
